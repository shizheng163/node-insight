# 什么是NodeJs

- [什么是NodeJs](#什么是nodejs)
  - [概念](#概念)
    - [单线程](#单线程)
    - [非阻塞IO](#非阻塞io)
  - [异步的事件驱动](#异步的事件驱动)
  - [轻量、适合可伸缩应用开发、适用实时交互应用](#轻量适合可伸缩应用开发适用实时交互应用)
  - [优点](#优点)
    - [高并发与I/O密集型应用](#高并发与io密集型应用)
    - [npm包管理器](#npm包管理器)
  - [缺点](#缺点)
  - [参考文章](#参考文章)

## 概念

> Node.js 是一个开源与跨平台的 JavaScript 运行环境。

-- 这是[官方网站](https://nodejs.org/en/)的描述

以下特性皆是通过官方文档中关于NodeJs的描述 https://nodejs.org/en/about/ 中的归纳总结

它具备如下特性:

- 单线程、所以无锁，无需担心死锁的问题
- 非阻塞IO: 除了标准库的同步方法外、其他API在执行IO时,进程永远不会阻塞
- 事件驱动、异步的
- 轻量、适合可伸缩应用开发、适用实时交互应用

它依赖 V8 JavaScript 引擎(Goole Chrome浏览器的内核) 去解析和执行Js代码，使Js代码可以在服务器端运行。

下面将针对上述特性一一进行详细描述:

### 单线程

Javascript仅仅是一门解释型语言，与平台无关，ECMAScirpt没有规定要有对net、fileSystem、dataBase等单元操作的能力。
但是当用作服务器开发时，网络、文件系统的操作是必不可少的。
所以NodeJs将这些操作封装为标准的JavascitptAPI，供用户调用，使Javascirpt在NodeJs中运行时具备了操作这些功能单元的能力。

用户在开发时，只需要编写Javascript代码，而不需要关心这些API在底层是如何实现的。

NodeJs在工作时会有很多的线程，但是执行javascript代码的线程只有一个，也就是说，用户编写的js代码，全部是在一个线程中完成的。

所以才说Nodejs是单线程的。由于js的代码都是一个线程中执行，所以就不存在死锁的概念了。

### 非阻塞IO

[传统IO的阻塞和非阻塞](https://blog.csdn.net/weixin_53153139/article/details/127349948)指的是用户调用和内核之间的等待关系。

在[NodeJs中的定义](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)如下:

> 阻塞是指在 Node.js 进程中执行其他 JavaScript 必须等到非 JavaScript 操作完成

除了一些标准库提供的阻塞API，其他的方法通常不会阻塞其他JavaSctipt的调用。
阻塞方法的名词通常以Sync结尾，例如`ReadFileSync`

请注意: 

- 占用CPU的Javascript代码在这里不被定位为阻塞，开发者应该谨慎编写占用CPU的代码用例。
- 所有阻塞的方法都提供了异步非阻塞的接口

这里有几个概念需要提及:
  
- 同步: 需要调用者定时轮询，查询状态来确定事件是否完成
- 异步: 事件做完之后，会自己调用一个回调函数，以此来发送通知

阻塞和非阻塞通常指的是API，而同步和异步值得是调用者获取API结果的方式。

## 异步的事件驱动

- [事件循环官方中文文档](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)
- [一张图带你看懂事件循环](https://juejin.cn/post/7010308647792148511)

关于事件驱动是什么，怎么执行，上述文章已经写的很好了，这里不再赘述。
下面补充一点个人的看法:

事件循环，事件驱动，事件到底是什么。

在我看来，事件就是一段可以连续执行的javascript代码。

例如下面的示例:

```js
console.log('hello,world!');
fs.readFile(path, callback1); // 读文件的伪代码
console.log('after call readFile');
setTimeout(callback2, 100);
```

在上面的代码中一共构建了三个事件。

第一个事件:

```js
console.log('hello,world!');
fs.readFile(); // 执行一些堆栈后结束函数，读文件的结果在回调中处理，当前线程不处理
console.log('after call readFile');
setTimeout(); // 创建一个计时器任务，然后返回
```

第二个事件:

```js
callback1();
```

第三个事件:

```js
callback2();
```

第二个和第三个事件的哪个先执行就看是读文件的速度快一点，还是计时器要求等待的100ms先到来了。

如果上述的代码就是node开始执行的脚本，那第一个事件其实就是主线程代码执行的经过。

主线程在执行自己的代码的过程中，可能创建了一些事件需要异步进行处理。当执行完主线程的代码，就需要判断是否有事件需要循环等待、发现有读文件的事件、有计时器的事件就会进入事件循环。没有的话，就退出脚本，结束进程。

进入事件循环之后，这些事件分别在多个阶段被调用处理，这里就不再赘述了，可以看上面的文章来进行了解。

那事件循环了解之后、什么是事件驱动呢？

事件循环，自然是要处理事件、那没有事件怎么办？ 挂起等候

等候有事件时再去处理，让事件去驱赶着这个循环往下走，去工作、所以就叫事件驱动。

就像开饭店一样，当饭店没客人时，饭店的运转就进入空闲、所有人无所事事、当有客人来吃饭之后、饭店的各项机能就开始运行。

客人来吃饭就是事件、客人来吃饭让大家动起来就是事件驱动。

## 轻量、适合可伸缩应用开发、适用实时交互应用

轻量: 使用简单，开发快、依赖少、内存占用少

同样是HTTP框架, NodeJs的HTTP服务和C++的Civetweb服务一对比，前者代码量少依赖少，开发简单，部署简单。
后者就比较笨重了。
用C++等重量级框架去开发一个简单的HTTP服务反而是大材小用。

适合可适合可伸缩应用开发:

NodeJs有高并发能力，[1百万连接仅消耗16G内存](https://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/)

无论上横向扩展还是纵向扩展都很合适。

适用实时交互应用:

- 实时交互应用要求并发高响应快，IO操作比较多，CPU操作(计算量)比较少。响应及时。比如聊天室。

## 优点

- 高并发(最重要的)
- 适合I/O密集型应用
- 成熟的包管理器:npm

### 高并发与I/O密集型应用

- [1百万连接仅消耗16G内存](https://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/)
- [传统的Web服务的并发能力是如何计算的](https://medium.com/the-node-js-collection/why-the-hell-would-you-use-node-js-4b053b94ab8e)

传统的Web服务, 每来一个网络请求就开一个线程，按照开一个线程为2MB的开销, 16GB内存的机器大约能支持8000的并发
而NodeJs只有一个线程，有TCP请求过来就创建一个事件运行端口监听的回调，上面的测试中发现1百万的连接仅仅消耗内存16G，足以证明并发能力有多强。
单又因为js代码的处理时单线程的，所以一个事件的处理过程不能占用太多的时间片，例如while(1)这种循环一定会阻塞其他事件的处理。
所以NodeJs适用于I/O操作比较多的场景、计算量多的场景(CPU密集型)的业务场景就不适合了。

### npm包管理器

npm官方站点:https://www.npmjs.com/

完整的生态，你可以轻松的找到你需要的第三方库，并且通道npm命令进行安装，并且都是开源的，可以在github上进行关注。

## 缺点

- 不适用CPU密集型的业务场景
- 不能充分的利用多核CPU的优势，不过可以通过集群的方式进行配置

## 参考文章

- [Why the Hell Would You Use Node.js](https://medium.com/the-node-js-collection/why-the-hell-would-you-use-node-js-4b053b94ab8e)